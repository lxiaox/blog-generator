---
title: JS中的数据结构
date: 2018-08-25 11:11:17
tags: （J）JS-数据结构
---
今天简要总结一下 JS 中的几种数据结构。

## 1、哈希

>哈希表(Hash table，也叫散列表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。

简单地说，形如键值一一对应的数据结构就是哈希。用哈希可以表示JS中的对象，根据是key-value对应，key表示对象属性，value表示属性值。如：

	var student = {
		'name': 'Mary',
		'sex': 'female',
		'age': '18',
	  //'key': 'value'
	}
其实**数组**就是一个特殊的哈希，它的 key 为排列好的数字,并且有一个key 是 length，表示数组长度。
	
	var array = [0,1,2,3]
	//可以看作
	var array = {
		'0': 0,
		'1': 1,
		'2': 2,
		'3': 3,
		'length': 4
	}
数组的优点是容易查找修改，缺点是难以在元素中间增加删除，因为每在中间增加或删除几个元素都意味着它之后的所有元素就要进行大挪移，都前进或都后退几位。


## 2、栈
栈是一种遵从**后进先出**（Last In First Out）的有序列表。栈顶元素永远是最新元素，每次只能从栈顶开始取出。可以想象成放在一只小箱子里的书本，每次往里放都放在最上面，也只能从最上面开始拿。栈的特点就是 先进后出，后进先出。

栈需要有如下的方法:

+ push(element(s)): 添加几个元素到栈顶
+ pop(): 移除并返回栈顶元素
+ peek(): 返回栈顶元素
+ isAmpty: 检查栈是否为空，为空则返回true
+ clear: 移除栈中所有元素
+ size: 返回栈中元素个数。
+ print: 以字符串显示栈中所有内容

## 3、队列
对列与栈很像，不过特点是 **先进先出**，这就跟我们人的排队是一样的。每次添加只能加在最后面，移除只能移除最前面的数据。

队列需要的方法：

+ enqueue(element(s)): 向队列尾部添加几个项
+ dequeue(): 移除队列的第一项
+ front(): 返回队列的第一个元素
+ 其他方法同栈一样。

## 4、链表
>链表是一组节点组成的集合，每个节点都使用一个对象的引用来指向它的后一个节点。指向另一节点的引用讲做链。

1. 单向链表中每个节点都具有两个部分，一个储存自身信息，一个指向下一个节点。
2. 双向链表中每个节点则具有三个部分，一个储存自身信息，一个指向上一个节点，一个指向下一个节点。

因此链表区别于数组的是容易增加删除，只需要改变指针指向即可，但是它想要找到一个节点却很困难，只能从第一个节点开始不停地找下一个节点直到找到。

*队列、栈可以用数组实现，而链表可以用哈希（即JS 对象）实现。*

这里说一下，哈希正是一种结合了数组和链表的优点的数据结构，既容易寻址查找，又容易插入删除。

## 5、树
之前的栈、队列、链表等都是顺序数据结构，而树就是一种**非顺序结构**。树形状像一颗根在上的倒挂的树，以此命名，如下图：

![树](http://p8rplhkt6.bkt.clouddn.com/tree1.png)
#### 树的基本概念：

+ 节点：树中的每个元素都叫节点；
+ 根节点：没有父节点的节点，树只有唯一的根节点，图中为 A；
+ 子节点：从节点延申而下的都叫子节点；
+ 内部节点：有子节点的节点（B C D）或称中间节点；
+ 叶子节点：没有子节点的节点(E F G H I J)，又称终端节点；
+ 节点层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；
+ 节点深度：从根 到 该节点的路径长，根的深度为0；
+ 节点高度：从该节点 到 一个叶子节点的最长路径长，叶子节点的高度为0；
+ 树的深度：所有节点深度的最大值；
+ 树的高度：所有节点高度的最大值；
+ 节点的度：一个节点含有的子树的个数称为该节点的度；
+ 树 的 度：一棵树中，最大的节点的度称为树的度；
+ 注：关于根节点的深度高度的基数为0 或1 说法不一。

#### 树的种类：

1. 无序树：树中任意节点的子节点之间没有顺序关系，也称为自由树；
2. 有序树：树中任意节点的子节点之间有顺序关系；
 + 二叉树：每个节点最多含有两个子树的树称为二叉树；
 + 霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二叉树；
 + B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。

其中二叉树又分为：

+ 完全二叉树：除了最底层，所有层的节点数均达到最大值，最底层的左右节点连续紧密地排列，这样的二叉树叫做完全二叉树。
+ 满二叉树：所有叶子节点均在最底层的二叉树。*满二叉树和完全二叉树用数组就可以表示*。

![满/完全二叉树](http://p8rplhkt6.bkt.clouddn.com/%E6%BB%A1-%E5%AE%8C%E5%85%A8-%E4%BA%8C%E5%8F%89%E6%A0%91.jpg)

+ 平衡二叉树（AVL树）：当且仅当任何节点的两棵子树的高度差不大于1的二叉树；
+ 排序二叉树(二叉查找树)：只允许你在左侧节点储存比父节点小的值，右侧只允许储存比父节点大的值。也称二叉搜索树、有序二叉树；

![二叉查找树](http://p8rplhkt6.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png)

##### 还有一种特殊的数据结构----堆
**堆(heap)**，形状上像完全二叉树，堆的特点是所有父节点都比它的子节点要大（最大堆） 或者要小（最小堆）。正如我们堆东西将大的放下面，小的放上面，树不能表现出这种特性，所以叫做堆。